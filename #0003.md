# リアクティブデータ

## リアクティブシステムの概要

- createAppメソッドのdataオプションに登録されたデータ(厳密には違うけど)
- オブジェクトの変化を検知して、ページに自動的に反映させる
- リアクティブデータを管理するVue.jsの仕組みを**リアクティブシステム**という

```html
<div id="app">
  <p>現在時刻：{{ current.toLocaleString() }}</p>
</div>
```

```js
Vue.createApp({
  data() {
    // 現在日時
    return {
      current: new Date()
    };
  },
  // 起動時にタイマーを設定
  created() {
    // mdn setInterval => https://developer.mozilla.org/ja/docs/Web/API/setInterval
    this.timer = setInterval(() => {
      this.current = new Date();
    }, 1000);
  },
  // 終了前にタイマーを破棄
  beforeUnmount() {
    clearInterval(this.timer);
  },
  // ページへのマウントで走る
  renderTracked(e) {
    console.log('renderTracked');
    console.log(e);
  },
  // データの更新で走る
  renderTriggered(e) {
    console.log('renderTriggered');
    console.log(e);
  }  
}).mount('#app');
```

- dataオプションにデータを登録すると、その全てのプロパティを監視対象として登録する
  - 内部的な挙動を意識して表現をすると、「Proxyオブジェクトでgetter/setterを生成する」
- 監視対象の値の変更を検知すると、自動的にビューに反映してくれる
- createdメソッドの部分では、setIntervalメソッドを経由して1000ミリ秒間隔で、currentプロパティの値を現在日時に置き換えている
- このようなタイマー設定では、createdフックを利用するのが定石


### createdとbeforeUnmount

- 後から破棄できるように、生成したタイマーはtimerプロパティに格納しておく
- beforeUnmountフックで、不要になったタイマーを破棄できるようになる
- createdやbeforeUnmountフックは、大概セットで利用する

### renderTracked / renderTriggered ライフサイクル

- **renderXxxxはリアクティブデータの変化を追跡するためのフック**で、主にデバッグ用途で使用する
  - 引数としてdebuggerイベントを受け取るので、この内容を確認することで、その時々の*リアクティブデータの状態を把握できる*
  - 例えば「target」プロパティを見れば、対象となるキーを把握できる
  - oldValue / newValue プロパティを見れば、更新前後の値を把握できる
- renderTrackedは「ページへのマウント」(描画で発生)
- renderTriggeredは「データの更新」で発生

## ビューの非同期更新を理解する

- リアクティブシステムによるビューの更新は非同期
- Vueはデータの変更を検知しても、これをすぐにビューに反映する訳ではない
- **連動として発生する全ての変更をプールした上で**、最終的な結果をビューに反映させる
  - 描画のオーバーヘッドを最小にとどめる効果があるから